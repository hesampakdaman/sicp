#+OPTIONS: num:2
#+STARTUP: show3levels
#+LATEX_HEADER: \usepackage[margin=1.5in]{geometry}
* Modularity, Objects, and State
** Assignment and Local State
*** Exercise 3.1
:PROPERTIES:
:header-args: :tangle "3.1.scm"
:END:
#+begin_quote
Write a procedure ~make-accumulator~ that generates accumulators, each maintaining an independent sum. The input to ~make-accumulator~ should specify the initial value of the sum.
#+end_quote
\noindent We will use ~set!~ to mutate the current accumulator ~sum~. After modifying the state we simply return the current value.
#+begin_src scheme
  (define (make-accumulator sum)
    (lambda (n)
      (set! sum (+ sum n))
      sum))
#+end_src
\noindent Now we can test our procedure by creating an accumulator that adds \( 5 \) to the current sum.
#+begin_src scheme
  (define A (make-accumulator 5))
  (= (A 10) 15)
  (= (A 10) 25)
#+end_src
\newpage

*** Exercise 3.2
:PROPERTIES:
:header-args: :tangle "3.2.scm"
:END:
#+begin_quote
Write a procedure ~make-monitored~ that takes as input a procedure, ~f~, that itself takes one input. The result returned by ~make-monitored~ is a third procedure, say ~mf~, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to ~mf~ is the special symbol ~how-many-calls?~, then ~mf~ returns the value of the counter. If the input is the special symbol ~reset-count~, then ~mf~ resets the counter to zero. For any other input, ~mf~ returns the result of calling ~f~ on that input and increments the counter.
#+end_quote
\noindent Let ~calls~ be a state variable for ~mf~ to mutate after each time ~f~ is called. The user can pass in the special symbol ~how-many-calls?~ to ~mf~ to see how many times ~f~ has been called.
#+begin_src scheme
  (define (make-monitored f)
    (let ((calls 0))
      (define (mf arg)
        (cond ((eq? arg 'how-many-calls?) calls)
              ((eq? arg 'reset-count) (set! calls 0) 0)
              (else (set! calls (+ calls 1))
                    (f arg))))
      mf))
#+end_src
\noindent We copy the test from the book to ensure our ~make-monitored~ works as expected. In addition we show that resetting the count also works as intended.
#+begin_src scheme
  (define s (make-monitored sqrt))
  (s 100)
  (= (s 'how-many-calls?) 1)
  (s 'reset-count 0)
  (= (s 'how-many-calls?) 0)
#+end_src
\newpage

*** Exercise 3.3
:PROPERTIES:
:header-args: :tangle "3.3.scm"
:END:
#+begin_quote
Modify the ~make-account~ procedure so that it creates password-protected accounts.
#+end_quote
Introduce a new state variable ~password~ where we store the user's password. It will be bound in the local environment from the arguments in ~make-account~. Install a new procedure ~wrong-password?~ in the dispatch that checks against it. Handle incorrect passwords by calling ~handle-incorrect-password~.
#+begin_src scheme
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (begin (set! balance (+ balance amount))
             balance))
    (define (handle-incorrect-password x)
      "Incorrect password")
    (define (wrong-password? pwd)
      (not (eq? pwd password)))
    (define (dispatch pwd m)
      (cond ((wrong-password? pwd) handle-incorrect-password)
            ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch)
#+end_src
Again the test from the book to verify our procedure.
#+begin_src scheme
  (define acc (make-account 100 'secret-password))
  (= ((acc 'secret-password 'withdraw) 40) 60)
  (string=? ((acc 'some-other-password 'deposit) 50) "Incorrect password")
#+end_src
\newpage

*** Exercise 3.4
:PROPERTIES:
:header-args: :tangle "3.4.scm"
:END:
#+begin_quote
Modify the make-account procedure of =Exercise 3.3= by adding another local state variable so that, if an account is accessed more than seven consecutive times with an incorrect password, it invokes the procedure ~call-the-cops~.
#+end_quote
The plan is to introduce a local state variable ~incorrect-attempts~ that holds the number of password attempts. We then modify ~handle-incorrect-password~ so that it increments the local state. If the number of attempts is more than \( 7 \) we simply call the cops, otherwise just output =Incorrect password= as usual.
#+begin_src scheme
  (define (make-account balance password)
    (define incorrect-attempts 0)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
      (define (deposit amount)
        (begin (set! balance (+ balance amount))
               balance))
    (define (signal-incorrect-password)
      "Incorrect password")
    (define (call-the-cops)
      "Calling the cops")
    (define (handle-incorrect-password x)
      (begin (set! incorrect-attempts (+ incorrect-attempts 1))
             (if (>= incorrect-attempts 7)
                 (call-the-cops)
                 (signal-incorrect-password))))
    (define (handle-request request)
      (set! incorrect-attempts 0)
      (cond ((eq? request 'withdraw) withdraw)
            ((eq? request 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT" request))))
    (define (wrong-password? pwd)
      (not (eq? pwd password)))
    (define (dispatch pwd m)
      (if (wrong-password? pwd)
          handle-incorrect-password
          (handle-request m)))
    dispatch)
#+end_src
As a test we create an account and provide the wrong password \( 7 \) times to see that the cops are called.
#+begin_src scheme
  (define acc (make-account 100 'secret-password))
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Calling the cops")

  (= ((acc 'secret-password 'deposit) 40) 140)
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
#+end_src
Note that after writing the correct password the number of attempts is reset.
\newpage

*** Exercise 3.5
:PROPERTIES:
:header-args: :tangle "3.5.scm"
:END:
#+begin_quote
Implement Monte Carlo integration as a procedure ~estimate-integral~ that takes as arguments a predicate \( P \), upper and lower bounds \( x_1, x_2, y_1 \) and \( y_2 \) for the rectangle, and the number of trials to perform in order to produce the estimate. Your procedure should use the same monte-carlo procedure that was used above to estimate \( \pi \) . Use your ~estimate-integral~ to produce an estimate of \( \pi \) by measuring the area of a unit circle.
#+end_quote
Let's first copy procedures ~monte-carlo~ and ~random-in-range~ from the book.
#+begin_src scheme
  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1)
                   (+ trials-passed 1)))
            (else (iter (- trials-remaining 1)
                        trials-passed))))
    (iter trials 0))

  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random range))))
#+end_src
Now we can implement ~estimate-integral~. We simply generate random points in the rectangle and check if they are in the unit circle. The ratio of points in the circle to the total number of points is an estimate of the area of the circle. Since the area of the circle is \( \pi \) we can multiply the ratio by the area of the rectangle to get an estimate of \( \pi \).
#+begin_src scheme
(define (estimate-integral P x1 x2 y1 y2 trials)
  (define (experiment)
    (let ((x (random-in-range x1 x2))
	  (y (random-in-range y1 y2)))
      (P x y)))
  (* (monte-carlo trials experiment) (* (- x2 x1) (- y2 y1))))
#+end_src
To get our result we define a predicate ~in-unit-circle?~ that checks if a point is in the unit circle. We then call ~estimate-integral~ with the predicate and the bounds of the unit circle.
#+begin_src scheme
  (define (in-unit-circle? x y) (<= (+ (square x) (square y)) 1))
  (define pi-approx (estimate-integral in-unit-circle? -1.0 1.0 -1.0 1.0 1000))
#+end_src
\newpage

*** Exercise 3.6
:PROPERTIES:
:header-args: :tangle "3.6.scm"
:END:
#+begin_quote
Design a new rand procedure that is called with an argument that is either the symbol ~generate~ or the symbol ~reset~ and behaves as follows: ~(rand 'generate)~ produces a new random number; ~((rand 'reset) ⟨new-value⟩)~ resets the internal state variable to the designated ~⟨new-value⟩~.
#+end_quote
Following the footnote instructions we create a simple ~rand-update~ with values for \( a, b\) and \( m \) chosen from Wikipedia's Linear congruential generator article.
#+begin_src scheme
  (define (rand-update x)
    (let ((a 4)
          (b 1)
          (m 9))
      (remainder (+ (* a x) b) m)))
#+end_src
Using this we can implement ~rand~. If the argument is ~generate~ we simply update the current state using ~rand-update~ and then return next value. If the argument is ~reset~ we set the state to the new value.
#+begin_src scheme
  (define rand
    (let ((x 0))
      (define (generate-random)
        (begin (set! x (rand-update x)) x))
      (define (reset-seed new-value)
        (begin (set! x new-value) '()))
      (define (dispatch m)
        (cond ((eq? m 'reset) reset-seed)
              ((eq? m 'generate) (generate-random))
              (else (error "Need a symbol 'reset or 'generate"))))
      dispatch))
#+end_src
Let's test our procedure by generating a random number and then resetting the seed to see if we get the same number again.
#+begin_src scheme
  (= (rand 'generate) 1)
  (= (rand 'generate) 5)
  ((rand 'reset) 0)
  (= (rand 'generate) 1)
  (= (rand 'generate) 5)
#+end_src
\newpage

*** Exercise 3.7
#+begin_quote
Suppose that our banking system requires the ability to make joint accounts. Define a procedure ~make-joint~ that accomplishes this. ~make-joint~ should take three arguments. The first is a password-protected account. The second argument must match the password with which the account was defined in order for the ~make-joint~ operation to proceed. The third argument is a new password. ~make-joint~ is to create an additional access to the original account using the new password.
#+end_quote
Let's grab our solution from =Exercise 3.3=.
#+begin_src scheme
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (begin (set! balance (+ balance amount))
             balance))
    (define (handle-incorrect-password x)
      "Incorrect password")
    (define (wrong-password? pwd)
      (not (eq? pwd password)))
    (define (dispatch pwd m)
      (cond ((wrong-password? pwd) handle-incorrect-password)
            ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch)
#+end_src
We create an additional procedure ~make-joint~ that uses the account if the password matches. Otherwise it signals incorrect password.
#+begin_src scheme
  (define (make-joint account account-password joint-password)
    (define (correct-password? pwd)
      (eq? pwd joint-password))
    (lambda (input-pwd request)
      (if (correct-password? input-pwd)
          (account account-password request)
          (lambda (_) "Incorrect password"))))
  #+end_src
Now we can test our procedure by creating a joint account and observing how the first account changes as we use the joint account.
#+begin_src scheme
  (define peter-acc (make-account 100 'open-sesame))
  (define paul-acc
    (make-joint peter-acc 'open-sesame 'rosebud))

  ;; test linked account
  (= ((peter-acc 'open-sesame 'withdraw) 40) 60)
  (= ((paul-acc 'rosebud 'deposit) 40) 100)

  ;; test wrong password for Paul
  (string=? ((paul-acc 'open-sesame 'withdraw) 100) "Incorrect password")

  ;; test insufficient funds for Peter
  (= ((paul-acc 'rosebud 'withdraw) 100) 0)
  (string=? ((peter-acc 'open-sesame 'withdraw) 1) "Insufficient funds")
#+end_src
\newpage

*** Exercise 3.8
:PROPERTIES:
:header-args: :tangle "3.8.scm"
:END:
#+begin_quote
Define a simple procedure ~f~ such that evaluating ~(+ (f 0) (f 1))~ will return \( 0 \) if the arguments to ~+~ are evaluated from left to right but will return \( 1 \) if the arguments are evaluated from right to left.
#+end_quote
We let ~f~ initialize a local state variable ~state~ to \( 0 \). Then we construct ~f~ such that it returns a function ~g~ that always mutates ~state~ to the value of its argument \( x \). The return value of ~g~ will be the old ~state~ value before the update.
#+begin_src scheme
  (define f
    (let ((state 0))
      (define (g x)
        (let ((old-state state))
          (begin (set! state x)
                 old-state)))
      g))
#+end_src
In the expression ~(+ (f 0) (f 1))~ if the arguments are evaluated left to right, then the first call to ~f~ will be ~(f 0)~ so ~state~ will equal to \( 0 \) and return value will be \( 0 \) since that was the old state value due to initialization. The subsequent ~(f 1)~ will update ~state~ to \( 1 \) but the function returns the old state value \( 0 \). The final value is thus ~(+ 0 0) = 0~.

Consequently, if the arguments are evaluated right to left, then the first call to ~f~ will be ~(f 1)~ and ~state~ would be set to \( 1 \), but due to initialization of ~state~ the old state value is \( 0 \) which is what we output. The next call ~(f 0)~ would set the ~state~ to \( 0 \), however this time the old ~state~ value is \( 1 \) which is what we output. Hence we have ~(+ 0  1) = 1~ as desired.
\newpage

** The Environment Model of Evaluation
*** Exercise 3.9
#+begin_quote
Show the environment structures created by evaluating ~(factorial 6)~ using each version of the factorial procedure.
#+end_quote
We start with the recursive version of the factorial program. ~(factorial n)~ is defined in the global environment which means that we must bind the name ~factorial~ to it there (and point back to the global environment). When ~(factorial 6)~ is invoked we create \( 6 \) different environments \( E_1, \ldots, E_6 \) where we have bound the formal parameter \( n \).
[[../images/ch3/ex-3.9/factorial-rec.jpg]]
In the last environment \( E_6 \) the function will return \( 1 \) since \( n = 1 \). This returned value will be propagated back to the caller in \( E_5 \) which will use that value for its calculation. This will continue until we reach \( E_1 \) where the final result is returned.

Let's now look at the iterative version of the factorial program. Again ~factorial~ is defined in the global environment as is ~factorial-iter~.  When ~(factorial 6)~ is called, this time the first environment \( E_1 \) will need to lookup ~(factorial-iter)~ which is found the global environment. So we create a new environment \( E_2 \) where we bind the formal parameters ~product~, ~counter~ and ~max-count~ using values from \( E_1 \). We create another frame \( E_3 \) for evaluating ~factorial-iter~ with parameters set by \( E_2 \). We iterate this way until we are in an environment where ~count~ greater than ~max-count~. This happens in \( E_8 \) and then   we return the value of ~product~ back to all previous callers.
[[../images/ch3/ex-3.9/factorial-iter.jpg]]
\newpage

*** Exercise 3.10
#+begin_quote
Use the environment model to analyze this alternate version (using ~let~ expression) of ~make-withdraw~, drawing figures like the ones above to illustrate the interactions
#+begin_src scheme
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
#+end_src
#+end_quote
The alternative version of ~make-withdraw~ is defined as follows in the book.
#+begin_src scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+end_src
We rewrite it by recalling that ~(let ((⟨var⟩ ⟨exp⟩)) ⟨body⟩)~ syntactic sugar for ~((lambda (⟨var⟩) ⟨body⟩) ⟨exp⟩)~.
#+begin_src scheme
  (define
   (make-withdraw initial-amount)
   ((lambda (balance)
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount)) balance)
          "Insufficient funds")))
    initial-amount))
#+end_src
When =(define W1 (make-withdraw 100))= we first need to evaluate the sub-expression ~(make-withdraw 100)~. To do that we create an environment \( E_1 \) where ~initial-amount~ is bound to \( 100 \) and evaluate the following expression.
#+begin_src scheme
  ((lambda (balance)
     (lambda (amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount)) balance)
         "Insufficient funds")))
   initial-amount) ;; bound to 100 in E_0
#+end_src
The result is a \( \lambda \)-expression together with an environment \( E_2 \) where ~balance~ is bound to \( 100 \). Since this new \( \lambda \)-expression was evaluated in \( E_1 \) it will point back to it rather than the global environment.
[[../images/ch3/ex-3.10/make-withdraw.jpg]]

When =(W1 50)= is evaluated we create a new environment \( E_3 \) where ~amount~ is bound to \( 50 \). We then evaluate the body of the \( \lambda \)-expression in \( E_3 \) and lookup ~balance~ which we find in \(E_2\). The result is \( 50 \) and the effect of =set!= is to change the value of =balance= in \( E_2 \) to \( 50 \). After this call is finished \( E_3 \) is discarded.
[[../images/ch3/ex-3.10/make-withdraw-50.jpg]]

Now when we run =(define W2 (make-withdraw 100))= we create a new environment \( E_5 \) where ~initial-amount~ is bound to \( 100 \). The new object =W2= is evaluated within \( E_5 \) so its environment where =balance= is bound to \( 100 \) will point to it.
[[../images/ch3/ex-3.10/make-withdraw-w2.jpg]]
\newpage

*** Exercise 3.11
#+begin_quote
Consider the bank account procedure of =Section 3.1.1=. Show the environment structure generated by the sequence of interactions
#+begin_src scheme
(define acc (make-account 50))
((acc 'deposit) 40)
90
((acc 'withdraw) 60)
30
#+end_src
Where is the local state for =acc= kept? Suppose we deﬁne another account
#+begin_src scheme
(define acc2 (make-account 100))
#+end_src
How are the local states for the two accounts kept distinct? Which parts of the environment structure are shared between =acc= and =acc2=?
#+end_quote

When =(define acc (make-account 50))= is called in the global environment we need to evaluate any sub-expressions. Beginning with the arguments =(make-account 50)=. Following the environment model we create a new frame in environment =E1= binding the formal paramter =balance= to \( 50 \). Then we bind all internal definitions of =withdraw=, =deposit= and =dispatch= in =E1=. Since =(make-account 50)= was called in the global environment =E1= will point to it. Since =(make-account 50)= returns =dispatch= that is what =acc= will be bound to in the global environment (which is where the =define= was called in first place).
[[../images/ch3/ex-3.11/make-acc.jpg]]

Now we proceed with =((acc 'deposit) 40)= by evaluating the sub-expression =(acc 'deposit)= in the global environment. =acc= points to the computational object =dispatch= and so we create a new environment =E2= where we bound the formal parameters of =dispatch= to ='deposit=. =E2= is enclosed by =E1= since that is the environment part of =dispatch=. The call to =(dispatch 'deposit)= returns the computational object =deposit=. Hence we need to evaluate =(deposit 40)=. We therefore create a new environment =E3= which will be enclosed by =E1=, again due to the fact that that is the environment part of =deposit=. In =E3= we bind the formal paramter of =deposit=, which is =amount= to \( 40 \). This call to =deposit= has the side-effect due to the use of =set!= in its body that mutates =balance= inside =E1=.
[[../images/ch3/ex-3.11/deposit.jpg]]

The =((acc 'withdraw) 60)= call is evaluated in a similar fashion creating two new ephermal environments =E4= and =E5=. The only difference is that =balance= is decremented.
[[../images/ch3/ex-3.11/withdraw.jpg]]

Finally, the call =(define acc2 (make-account 100))= sets up a new environment =E6= where =balance= is bound to \( 100 \). We see here that the two accounts are kept distinct by the fact that they have different environments. The only environment structure that shared between the two accounts is the global environment.
[[../images/ch3/ex-3.11/make-acc2.jpg]]
\newpage

** Modeling with Mutable Data
*** Exercise 3.12
#+begin_quote
Consider the interaction
#+begin_src scheme
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
(a b c d)
(cdr x)
⟨response⟩
(define w (append! x y))
w
(a b c d)
(cdr x)
⟨response⟩
#+end_src
What are the missing =⟨response⟩=? Draw box-and-pointer diagrams to explain your answer.
#+end_quote
We draw the box-and-pointer diagram for state up until defining the variable =z=. [[../images/ch3/ex-3.12/define-z.jpg]]
In doing so we see that the the first missing ~⟨response⟩~ is =(b)=. Let's now draw the diagram after =w= is defined. We are using the mutator procedure =append!= so the list structure is modified in-place. [[../images/ch3/ex-3.12/define-w.jpg]]
This time the missing response will be =(b c d)= since =x= was mutated when =w= was defined.
\newpage
*** Exercise 3.13
#+begin_quote
Consider the following make-cycle procedure, which uses the =last-pair= procedure deﬁned in Exercise 3.12:
#+begin_src scheme
  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
#+end_src
Draw a box-and-pointer diagram that shows the structure =z= created by
#+begin_src scheme
  (define z (make-cycle (list 'a 'b 'c)))
#+end_src
What happens if we try to compute ~(last-pair z)~?
#+end_quote
The procedure =make-cycle= will set the last pair's =cdr= of =(list 'a 'b 'c)= to the head of itself. This means that we have created a cycle over the ='(a b c)=. We draw the box-and-pointer diagram for =z= below.
[[../images/ch3/ex-3.13/cycle.jpg]]
As can be seen in the diagram above, if we try to evaluate ~(last-pair z)~ we will get an infinite loop since the last pair of =z= points to itself.
\newpage

*** Exercise 3.14
#+begin_quote
The following procedure is quite useful, although obscure:
#+begin_src scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+end_src
Draw the box-and-pointer diagram that represents the list to which v is bound. Suppose that we now evaluate =(define w (mystery v))=. Draw box-and-pointer diagrams that show the structures =v= and =w= after evaluating this expression. What would be printed as the values of =v= and =w=?
#+end_quote
We can observe that the value of =x= in =loop= will always be the tail of the previous =x= value. So that =temp= would be =(a b c d)=, =(b c d)=, ..., =(d)=, =()=. The =y= is always the previous iteration's mutated =x= value beginning with the empty list =()=. Since =x= is changed by taking its head and setting its =cdr= to be =y=, the values =y= take in each iteration are =()=, =(a)=, =(b a)=, ..., =(d c b a)=. This means that =(mystery x)= is effectively reversing the list =x=.

We draw the box-and-pointer diagram for =v= below.
[[../images/ch3/ex-3.14/define-v.jpg]]

After the call =(define w (mystery v))= we have reversed the list =v= and bound it to =w=. However, the first =set-cdr!= in =loop= will mutate the value pointed by =v= by setting the =cdr= to =y= which is initialized by the empty list. In the next iteration, =v= will be passed in =loop= as =y= which is not mutated and in fact dropped. This means we only mutate the value of =v= once to =(a)=. We draw the box-and-pointer diagram for =v= and =w= below.
[[../images/ch3/ex-3.14/define-w.jpg]]
\newpage

*** Exercise 3.15
#+begin_quote
Draw box-and-pointer diagrams to explain the effect of set-to-wow! on the structures =z1= and =z2= above.
#+end_quote
We draw the box-and-pointer diagram for =z1= and =z2= after the effects calling =set-to-wow!= on both of them, respectively.
[[../images/ch3/ex-3.15/set-to-wow.jpg]]

*** Exercise 3.16
:PROPERTIES:
:header-args: :tangle "3.16.scm"
:END:
#+begin_quote
The number of pairs in any structure is the number in the car plus the number in the =cdr= plus one more to count the current pair.
#+begin_src scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+end_src
Show that this procedure is not correct. In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben’s procedure would return 3; return 4; return 7; never return at all.
#+end_quote
We begin with the first two cases, where we construct =w= to return 3 and =x= to return 4.
#+begin_src scheme
  (define b (cons 'b '()))
  (define a (cons 'a b))

  (define w (cons a '()))
  (count-pairs w)                         ; returns 3

  (define x (cons a b))
  (count-pairs x)                         ; returns 4
#+end_src
The diagrams for these two cases are shown below.
[[../images/ch3/ex-3.16/pair-3-4.jpg]]
For the third we construct =y= to return 7.
#+begin_src scheme
  (define bb (cons b b))
  (define y (cons bb bb))
  (count-pairs y)                         ; returns 7
#+end_src
For the last case we simply let =z= to be a cycle using the =make-cycle= procedure from =Exercise 3.13=. We show diagrams below
 #+begin_src scheme
   (define (make-cycle x)
     (set-cdr! (last-pair x) x)
     x)

   (define z (make-cycle (cons 'a (cons 'b (cons 'c '())))))
   ;; (count-pairs z)                         ; will never halt
 #+end_src
[[../images/ch3/ex-3.16/pair-7-inf.jpg]]
\newpage

*** Exercise 3.17
#+begin_quote
Devise a correct version of the count-pairs procedure of =Exercise 3.16= that returns the number of distinct pairs in any structure. (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)
#+end_quote
We will implement a set data structure, admittedly ineffienct. We will use the =memq= procedure to check if an element is in the set and =cons= to add the element to the set. The number of pairs will be the length of our set.
#+begin_src scheme
  (define (count-pairs x)
    (define seen-pair '())
    (define (count x)
      (cond ((not (pair? x)) 0)
            ((memq x seen-pair) 0)
            (else (set! seen-pair (cons x seen-pair))
                  (+ (count (car x))
                     (count (cdr x))
                     1))))
    (count x))
#+end_src
Using this new version of =count-pairs= with the list structres we defined in =Exercise 3.16=, all results are returned correctly as 3.
\newpage

*** Exercise 3.18
:PROPERTIES:
:header-args: :tangle "3.18.scm"
:END:
#+begin_quote
Write a procedure that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive =cdrs= would go into an infinite loop. =Exercise 3.13= constructed such lists.
#+end_quote
We can construct a path of =cons= by following each successive =cdr= of a list. If such a path of =cons= has a cycle, then at least one of the =cons= in the path points back to a previous =cons= in the path. We write the procedure =has-cycle?= using this fact.
#+begin_src scheme
  (define (has-cycle? x)
    (define (cycle-in-path? x path)
      (cond ((not (pair? x)) #f)
            ((memq (cdr x) path) #t)
            (else (cycle-in-path? (cdr x) (cons x path)))))
    (cycle-in-path? x (list x)))
#+end_src
Let's test this procedure by creating a cycle and a non-cycle. From =Exercise 3.13= we use the procedure =make-cycle=.
#+begin_src scheme
  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
#+end_src
Next let us define =x= with no cycle and =z= with a cycle.
#+begin_src scheme
  (define x '(a b c))
  (define z (cons 'a (make-cycle (cons 'a 'b))))
#+end_src
We can now test our procedure by calling =has-cycle?= on =x= and =z=.
#+begin_src scheme
  (has-cycle? x)                           ; returns #f
  (has-cycle? z)                           ; returns #t
#+end_src
However, note that we construct the path by =cdr=-ing down the list. This means that if we have a cycle in the =car= part of the list, then we will not detect it. We could easily amend this by adjusting the =cycle-in-path?= to check for cycles in the =car= part of the list as well.
#+begin_src scheme
  (define (cycle-in-path? x path)
    (cond ((not (pair? x)) #f)
          ((or (memq (car x) path) (memq (cdr x) path)) #t)
          (else (or (cycle-in-path? (car x) (cons x path))
                    (cycle-in-path? (cdr x) (cons x path))))))
#+end_src
\newpage

*** Exercise 3.19
#+begin_quote
Redo =Exercise 3.18= using an algorithm that takes only a constant amount of space. (This requires a very clever idea.)
#+end_quote
We can use the famous =tortoise-and-hare= algorithm for detecting cycles in a list. The idea is to have two pointers, one that moves one step at a time and another that moves two steps at a time. If there is a cycle in the list, then the two pointers will eventually point to the same =cons= in the list. We omit the proof here.

Since we only use two pointers to travers in addition to the list, this algorithm takes constant space. We write the procedure =has-cycle?= using this idea.
#+begin_src scheme
  (define (has-cycle? x)
    (define (tortoise-and-hare tortoise hare)
      (cond ((not (pair? hare)) #f)
            ((eq? tortoise hare) #t)
            (else (tortoise-and-hare (cdr tortoise) (cddr hare)))))
    (tortoise-and-hare x (cdr x)))
#+end_src
Note that the procedure above only works for non-empty lists. We can easily amend this by adding a conditional before the call to =tortoise-and-hare= in =has-cycle?=. But we omit it to not clutter the code.
\newpage

*** Exercise 3.20
#+begin_quote
Draw environment diagrams to illustrate the evaluation of the sequence of expressions
#+begin_src scheme
  (define x (cons 1 2))
  (define z (cons x x))
  (set-car! (cdr z) 17)
  (car x)
  17
#+end_src
using the procedural implementation of pairs given above. (Compare =Exercise 3.11=.)
#+end_quote
=cons= points to a procedure enclosed by the global environment with parameters =x, y=. When defining =x= we create a new frame =E1= where we bound =cons= parameters to =1, 2= and evaluate the body. We see the result in the diagram below.
[[../images/ch3/ex-3.20/define-x.jpg]]

Similarly, when defining =z= we create a new frame =E2=, but this time bound =cons= parameters to =x, x=.
[[../images/ch3/ex-3.20/define-z.jpg]]

Now we want to evaluate the compound expression =(set-car! (cdr z) 17)=. First we need to evaluate all sub-expressions. This means we begin with =(cdr z)= since =17= is a primitve. Therefore we create a new frame =E3= where we bound =cdr= parameters to =z= and evaluate the body.

This leaves us the expression =(z 'cdr)= and we look in the global enviroment after =z=. We find that =z= points to a procedural object called =dispatch= in =E2=. As before, create a new frame =E4= and bind the =dispatch='s parameter =m= to ='cdr=. Evaluation of the body gives us the symbol =x=.

The expression we need to evaluate now is =(set-car! x 17)=. At this point every sub-expression is known in the global environment so we must apply =set-car!= to the parameters. Hence, we create a new frame =E5= and bind =set-car!='s parameters to =x, 17= and leaves us with the expression =(((x 'set-car!) 17) x)=.

The sub-expression =(x 'set-car!)= is evaluated in a new frame =E6= and results in =set-x!= procedure defined in enviroment =E1=. We have =((set-x! 17) x)= left to evaluate. For =(set-x! 17)= we create a new frame =E7= enclosed by =E1=. Following the procedure =set-x!= and binding its parameter to =17= has the effect of setting the =car= of =x= to the value =17=. Lastly, we just return =x= back to the caller.
[[../images/ch3/ex-3.20/set-car.jpg]]

The final result is that the =car= value of =x= was mutated. Since =cdr z= points to =x=, =z= will also be affected by this as a side-effect.
[[../images/ch3/ex-3.20/final.jpg]]

=Exercise 3.11= is similar in that we have internal definitions and variables. So the two evaluations of =cons= leads to two enviroments =E1= and =E2=, both of which have their own =dispatch=, exactly as in =Exercise 3.11=. However, a difference here is that when defining =z= we bind it to the previously created =x= -- in effect coupling them as we've seen in the final result.
\newpage

*** Exercise 3.21
#+begin_quote
Ben Bitdiddle decides to test the queue implementation described above. “It’s all wrong!” he complains. “The interpreter’s response shows that the last item is inserted into the queue twice. Show why Ben’s examples produce the printed results that they do. Define a procedure =print-queue= that takes a queue as input and prints the sequence of items in the queue.
#+end_quote
A sequence of =cons= terminated by ='()= is printed as a list in Scheme. Hence
#+begin_src scheme
  (cons 'a '())
  (a)
  (cons 'a 'b)
  (a . b)
#+end_src
When we evaluate the following expressions, as Ben Bitdiddle does,
#+begin_src scheme
  (define q1 (make-queue))
  (insert-queue! q1 'a)
#+end_src
then =q1= will point to the pair =(cons (cons 'a '()) (cons 'a '()))=. Therefore the print will be
#+begin_src scheme
  ((a) a)
#+end_src
There's a nested parenthesis to distinguish that the =car= is a list in its own, which we wouldn't have seen if it was printed without them like so =(a a)=. Subsequent insertion =(insert-queue! q1 'b)= will make =q1= to point to the pair =(cons (cons 'a (cons 'b '())) (cons 'b '()))= and print =((a b) b)=. However, do note that =rear-ptr= is just a pointer to the =last-pair= in =(cons 'a (cons 'b '()))= as can be seen in the diagram below.
#+ATTR_LATEX: :width 0.40\textwidth
[[../images/ch3/ex-3.21/insert-queue.jpg]]
To define a procedure =print-queue= we simply traverse the queue starting from the =front-ptr= and =cdr= until we reach the end of the queue. We print the =car= of each pair along the way. But this is what Scheme already does when we print a list. So we can just return the =front-ptr= and Scheme will print it for us.
#+begin_src scheme
  (define (print-queue q)
    (front-ptr q))
#+end_src
\newpage

*** Exercise 3.22
#+begin_quote
Complete the definition of =make-queue= and provide implementations of the queue operations using this representation.
#+begin_src scheme
  (define (make-queue)
    (let ((front-ptr . . . )
          (rear-ptr . . . ))
      ⟨definitions of internal procedures⟩
      (define (dispatch m) . . .)
      dispatch))
#+end_src
#+end_quote
We initialize =front-ptr= and =rear-ptr= to be empty lists. Whenever we insert an =item=, we simply tack the pair =(cons item '())= onto the current rear, and then =set!= the =rear-ptr= to this pair. For deletion we simply set =front-ptr= to its =cdr=.
#+begin_src scheme
  (define (make-queue)
    (let ((front-ptr '())
          (rear-ptr '()))
      (define (empty?) (null? front-ptr))
      (define (insert! item)
        (let ((new-pair (cons item '())))
          (cond ((empty?)
                 (set! front-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr)
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr))))
      (define (delete!) (set! front-ptr (cdr front-ptr)) front-ptr)
      (define (dispatch m)
        (cond ((eq? m 'empty?) (empty?))
              ((eq? m 'front) (car front-ptr))
              ((eq? m 'insert!) insert!)
              ((eq? m 'delete) (delete!))
              ((eq? m 'print) front-ptr)))
      dispatch))
#+end_src
Now we define the rest of interface for =queue= in terms of the =dispatch=.
#+begin_src scheme
  (define (delete-queue! queue) (queue 'delete))
  (define (empty-queue? queue) (queue 'empty?))
  (define (front-queue queue) (queue 'front))
  (define (insert-queue! queue item) ((queue 'insert!) item))
  (define (print-queue queue) (queue 'print))
#+end_src
