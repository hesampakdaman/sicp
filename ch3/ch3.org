#+OPTIONS: num:2
#+STARTUP: show3levels
#+LATEX_HEADER: \usepackage[margin=1.5in]{geometry}
* Modularity, Objects, and State
** Assignment and Local State
*** Exercise 3.1
:PROPERTIES:
:header-args: :tangle "3.1.scm"
:END:
#+begin_quote
Write a procedure ~make-accumulator~ that generates accumulators, each maintaining an independent sum. The input to ~make-accumulator~ should specify the initial value of the sum.
#+end_quote
\noindent We will use ~set!~ to mutate the current accumulator ~sum~. After modifying the state we simply return the current value.
#+begin_src scheme
  (define (make-accumulator sum)
    (lambda (n)
      (set! sum (+ sum n))
      sum))
#+end_src
\noindent Now we can test our procedure by creating an accumulator that adds \( 5 \) to the current sum.
#+begin_src scheme
  (define A (make-accumulator 5))
  (= (A 10) 15)
  (= (A 10) 25)
#+end_src
\newpage

*** Exercise 3.2
:PROPERTIES:
:header-args: :tangle "3.2.scm"
:END:
#+begin_quote
Write a procedure ~make-monitored~ that takes as input a procedure, ~f~, that itself takes one input. The result returned by ~make-monitored~ is a third procedure, say ~mf~, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to ~mf~ is the special symbol ~how-many-calls?~, then ~mf~ returns the value of the counter. If the input is the special symbol ~reset-count~, then ~mf~ resets the counter to zero. For any other input, ~mf~ returns the result of calling ~f~ on that input and increments the counter.
#+end_quote
\noindent Let ~calls~ be a state variable for ~mf~ to mutate after each time ~f~ is called. The user can pass in the special symbol ~how-many-calls?~ to ~mf~ to see how many times ~f~ has been called.
#+begin_src scheme
  (define (make-monitored f)
    (let ((calls 0))
      (define (mf arg)
        (cond ((eq? arg 'how-many-calls?) calls)
              ((eq? arg 'reset-count) (set! calls 0) 0)
              (else (set! calls (+ calls 1))
                    (f arg))))
      mf))
#+end_src
\noindent We copy the test from the book to ensure our ~make-monitored~ works as expected. In addition we show that resetting the count also works as intended.
#+begin_src scheme
  (define s (make-monitored sqrt))
  (s 100)
  (= (s 'how-many-calls?) 1)
  (s 'reset-count 0)
  (= (s 'how-many-calls?) 0)
#+end_src
\newpage

*** Exercise 3.3
:PROPERTIES:
:header-args: :tangle "3.3.scm"
:END:
#+begin_quote
Modify the ~make-account~ procedure so that it creates password-protected accounts.
#+end_quote
Introduce a new state variable ~password~ where we store the user's password. It will be bound in the local environment from the arguments in ~make-account~. Install a new procedure ~wrong-password?~ in the dispatch that checks against it. Handle incorrect passwords by calling ~handle-incorrect-password~.
#+begin_src scheme
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (begin (set! balance (+ balance amount))
             balance))
    (define (handle-incorrect-password x)
      "Incorrect password")
    (define (wrong-password? pwd)
      (not (eq? pwd password)))
    (define (dispatch pwd m)
      (cond ((wrong-password? pwd) handle-incorrect-password)
            ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch)
#+end_src
Again the test from the book to verify our procedure.
#+begin_src scheme
  (define acc (make-account 100 'secret-password))
  (= ((acc 'secret-password 'withdraw) 40) 60)
  (string=? ((acc 'some-other-password 'deposit) 50) "Incorrect password")
#+end_src
\newpage

*** Exercise 3.4
:PROPERTIES:
:header-args: :tangle "3.4.scm"
:END:
#+begin_quote
Modify the make-account procedure of =Exercise 3.3= by adding another local state variable so that, if an account is accessed more than seven consecutive times with an incorrect password, it invokes the procedure ~call-the-cops~.
#+end_quote
The plan is to introduce a local state variable ~incorrect-attempts~ that holds the number of password attempts. We then modify ~handle-incorrect-password~ so that it increments the local state. If the number of attempts is more than \( 7 \) we simply call the cops, otherwise just output =Incorrect password= as usual.
#+begin_src scheme
  (define (make-account balance password)
    (define incorrect-attempts 0)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
      (define (deposit amount)
        (begin (set! balance (+ balance amount))
               balance))
    (define (signal-incorrect-password)
      "Incorrect password")
    (define (call-the-cops)
      "Calling the cops")
    (define (handle-incorrect-password x)
      (begin (set! incorrect-attempts (+ incorrect-attempts 1))
             (if (>= incorrect-attempts 7)
                 (call-the-cops)
                 (signal-incorrect-password))))
    (define (handle-request request)
      (set! incorrect-attempts 0)
      (cond ((eq? request 'withdraw) withdraw)
            ((eq? request 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT" request))))
    (define (wrong-password? pwd)
      (not (eq? pwd password)))
    (define (dispatch pwd m)
      (if (wrong-password? pwd)
          handle-incorrect-password
          (handle-request m)))
    dispatch)
#+end_src
As a test we create an account and provide the wrong password \( 7 \) times to see that the cops are called.
#+begin_src scheme
  (define acc (make-account 100 'secret-password))
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
  (string=? ((acc 'some-other-password 'deposit) 40) "Calling the cops")

  (= ((acc 'secret-password 'deposit) 40) 140)
  (string=? ((acc 'some-other-password 'deposit) 40) "Incorrect password")
#+end_src
Note that after writing the correct password the number of attempts is reset.
\newpage

*** Exercise 3.5
:PROPERTIES:
:header-args: :tangle "3.5.scm"
:END:
#+begin_quote
Implement Monte Carlo integration as a procedure ~estimate-integral~ that takes as arguments a predicate \( P \), upper and lower bounds \( x_1, x_2, y_1 \) and \( y_2 \) for the rectangle, and the number of trials to perform in order to produce the estimate. Your procedure should use the same monte-carlo procedure that was used above to estimate \( \pi \) . Use your ~estimate-integral~ to produce an estimate of \( \pi \) by measuring the area of a unit circle.
#+end_quote
Let's first copy procedures ~monte-carlo~ and ~random-in-range~ from the book.
#+begin_src scheme
  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1)
                   (+ trials-passed 1)))
            (else (iter (- trials-remaining 1)
                        trials-passed))))
    (iter trials 0))

  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random range))))
#+end_src
Now we can implement ~estimate-integral~. We simply generate random points in the rectangle and check if they are in the unit circle. The ratio of points in the circle to the total number of points is an estimate of the area of the circle. Since the area of the circle is \( \pi \) we can multiply the ratio by the area of the rectangle to get an estimate of \( \pi \).
#+begin_src scheme
(define (estimate-integral P x1 x2 y1 y2 trials)
  (define (experiment)
    (let ((x (random-in-range x1 x2))
	  (y (random-in-range y1 y2)))
      (P x y)))
  (* (monte-carlo trials experiment) (* (- x2 x1) (- y2 y1))))
#+end_src
To get our result we define a predicate ~in-unit-circle?~ that checks if a point is in the unit circle. We then call ~estimate-integral~ with the predicate and the bounds of the unit circle.
#+begin_src scheme
  (define (in-unit-circle? x y) (<= (+ (square x) (square y)) 1))
  (define pi-approx (estimate-integral in-unit-circle? -1.0 1.0 -1.0 1.0 1000))
#+end_src
\newpage

*** Exercise 3.6
:PROPERTIES:
:header-args: :tangle "3.6.scm"
:END:
#+begin_quote
Design a new rand procedure that is called with an argument that is either the symbol ~generate~ or the symbol ~reset~ and behaves as follows: ~(rand 'generate)~ produces a new random number; ~((rand 'reset) ⟨new-value⟩)~ resets the internal state variable to the designated ~⟨new-value⟩~.
#+end_quote
Following the footnote instructions we create a simple ~rand-update~ with values for \( a, b\) and \( m \) chosen from Wikipedia's Linear congruential generator article.
#+begin_src scheme
  (define (rand-update x)
    (let ((a 4)
          (b 1)
          (m 9))
      (remainder (+ (* a x) b) m)))
#+end_src
Using this we can implement ~rand~. If the argument is ~generate~ we simply update the current state using ~rand-update~ and then return next value. If the argument is ~reset~ we set the state to the new value.
#+begin_src scheme
  (define rand
    (let ((x 0))
      (define (generate-random)
        (begin (set! x (rand-update x)) x))
      (define (reset-seed new-value)
        (begin (set! x new-value) '()))
      (define (dispatch m)
        (cond ((eq? m 'reset) reset-seed)
              ((eq? m 'generate) (generate-random))
              (else (error "Need a symbol 'reset or 'generate"))))
      dispatch))
#+end_src
Let's test our procedure by generating a random number and then resetting the seed to see if we get the same number again.
#+begin_src scheme
  (= (rand 'generate) 1)
  (= (rand 'generate) 5)
  ((rand 'reset) 0)
  (= (rand 'generate) 1)
  (= (rand 'generate) 5)
#+end_src
\newpage

*** Exercise 3.7
#+begin_quote
Suppose that our banking system requires the ability to make joint accounts. Define a procedure ~make-joint~ that accomplishes this. ~make-joint~ should take three arguments. The first is a password-protected account. The second argument must match the password with which the account was defined in order for the ~make-joint~ operation to proceed. The third argument is a new password. ~make-joint~ is to create an additional access to the original account using the new password.
#+end_quote
Let's grab our solution from =Exercise 3.3=.
#+begin_src scheme
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (begin (set! balance (+ balance amount))
             balance))
    (define (handle-incorrect-password x)
      "Incorrect password")
    (define (wrong-password? pwd)
      (not (eq? pwd password)))
    (define (dispatch pwd m)
      (cond ((wrong-password? pwd) handle-incorrect-password)
            ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch)
#+end_src
We create an additional procedure ~make-joint~ that uses the account if the password matches. Otherwise it signals incorrect password.
#+begin_src scheme
  (define (make-joint account account-password joint-password)
    (define (correct-password? pwd)
      (eq? pwd joint-password))
    (lambda (input-pwd request)
      (if (correct-password? input-pwd)
          (account account-password request)
          (lambda (_) "Incorrect password"))))
  #+end_src
Now we can test our procedure by creating a joint account and observing how the first account changes as we use the joint account.
#+begin_src scheme
  (define peter-acc (make-account 100 'open-sesame))
  (define paul-acc
    (make-joint peter-acc 'open-sesame 'rosebud))

  ;; test linked account
  (= ((peter-acc 'open-sesame 'withdraw) 40) 60)
  (= ((paul-acc 'rosebud 'deposit) 40) 100)

  ;; test wrong password for Paul
  (string=? ((paul-acc 'open-sesame 'withdraw) 100) "Incorrect password")

  ;; test insufficient funds for Peter
  (= ((paul-acc 'rosebud 'withdraw) 100) 0)
  (string=? ((peter-acc 'open-sesame 'withdraw) 1) "Insufficient funds")
#+end_src
\newpage

*** Exercise 3.8
:PROPERTIES:
:header-args: :tangle "3.8.scm"
:END:
#+begin_quote
Define a simple procedure ~f~ such that evaluating ~(+ (f 0) (f 1))~ will return \( 0 \) if the arguments to ~+~ are evaluated from left to right but will return \( 1 \) if the arguments are evaluated from right to left.
#+end_quote
We let ~f~ initialize a local state variable ~state~ to \( 0 \). Then we construct ~f~ such that it returns a function ~g~ that always mutates ~state~ to the value of its argument \( x \). The return value of ~g~ will be the old ~state~ value before the update.
#+begin_src scheme
  (define f
    (let ((state 0))
      (define (g x)
        (let ((old-state state))
          (begin (set! state x)
                 old-state)))
      g))
#+end_src
In the expression ~(+ (f 0) (f 1))~ if the arguments are evaluated left to right, then the first call to ~f~ will be ~(f 0)~ so ~state~ will equal to \( 0 \) and return value will be \( 0 \) since that was the old state value due to initialization. The subsequent ~(f 1)~ will update ~state~ to \( 1 \) but the function returns the old state value \( 0 \). The final value is thus ~(+ 0 0) = 0~.

Consequently, if the arguments are evaluated right to left, then the first call to ~f~ will be ~(f 1)~ and ~state~ would be set to \( 1 \), but due to initialization of ~state~ the old state value is \( 0 \) which is what we output. The next call ~(f 0)~ would set the ~state~ to \( 0 \), however this time the old ~state~ value is \( 1 \) which is what we output. Hence we have ~(+ 0  1) = 1~ as desired.
\newpage

** The Environment Model of Evaluation
*** Exercise 3.9
#+begin_quote
Show the environment structures created by evaluating ~(factorial 6)~ using each version of the factorial procedure.
#+end_quote
We start with the recursive version of the factorial program. ~(factorial n)~ is defined in the global environment which means that we must bind the name ~factorial~ to it there (and point back to the global environment). When ~(factorial 6)~ is invoked we create \( 6 \) different environments \( E_1, \ldots, E_6 \) where we have bound the formal parameter \( n \).
[[../images/ch3/ex-3.9/factorial-rec.jpg]]
In the last environment \( E_6 \) the function will return \( 1 \) since \( n = 1 \). This returned value will be propagated back to the caller in \( E_5 \) which will use that value for its calculation. This will continue until we reach \( E_1 \) where the final result is returned.

Let's now look at the iterative version of the factorial program. Again ~factorial~ is defined in the global environment as is ~factorial-iter~.  When ~(factorial 6)~ is called, this time the first environment \( E_1 \) will need to lookup ~(factorial-iter)~ which is found the global environment. So we create a new environment \( E_2 \) where we bind the formal parameters ~product~, ~counter~ and ~max-count~ using values from \( E_1 \). We create another frame \( E_3 \) for evaluating ~factorial-iter~ with parameters set by \( E_2 \). We iterate this way until we are in an environment where ~count~ greater than ~max-count~. This happens in \( E_8 \) and then   we return the value of ~product~ back to all previous callers.
[[../images/ch3/ex-3.9/factorial-iter.jpg]]
\newpage

*** Exercise 3.10
#+begin_quote
Use the environment model to analyze this alternate version (using ~let~ expression) of ~make-withdraw~, drawing figures like the ones above to illustrate the interactions
#+begin_src scheme
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
#+end_src
#+end_quote
The alternative version of ~make-withdraw~ is defined as follows in the book.
#+begin_src scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))))
#+end_src
We rewrite it by recalling that ~(let ((⟨var⟩ ⟨exp⟩)) ⟨body⟩)~ syntactic sugar for ~((lambda (⟨var⟩) ⟨body⟩) ⟨exp⟩)~.
#+begin_src scheme
  (define
   (make-withdraw initial-amount)
   ((lambda (balance)
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount)) balance)
          "Insufficient funds")))
    initial-amount))
#+end_src
When =(define W1 (make-withdraw 100))= we first need to evaluate the sub-expression ~(make-withdraw 100)~. To do that we create an environment \( E_1 \) where ~initial-amount~ is bound to \( 100 \) and evaluate the following expression.
#+begin_src scheme
  ((lambda (balance)
     (lambda (amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount)) balance)
         "Insufficient funds")))
   initial-amount) ;; bound to 100 in E_0
#+end_src
The result is a \( \lambda \)-expression together with an environment \( E_2 \) where ~balance~ is bound to \( 100 \). Since this new \( \lambda \)-expression was evaluated in \( E_1 \) it will point back to it rather than the global environment.
[[../images/ch3/ex-3.10/make-withdraw.jpg]]

When =(W1 50)= is evaluated we create a new environment \( E_3 \) where ~amount~ is bound to \( 50 \). We then evaluate the body of the \( \lambda \)-expression in \( E_3 \) and lookup ~balance~ which we find in \(E_2\). The result is \( 50 \) and the effect of =set!= is to change the value of =balance= in \( E_2 \) to \( 50 \). After this call is finished \( E_3 \) is discarded.
[[../images/ch3/ex-3.10/make-withdraw-50.jpg]]

Now when we run =(define W2 (make-withdraw 100))= we create a new environment \( E_5 \) where ~initial-amount~ is bound to \( 100 \). The new object =W2= is evaluated within \( E_5 \) so its environment where =balance= is bound to \( 100 \) will point to it.
[[../images/ch3/ex-3.10/make-withdraw-w2.jpg]]
\newpage

*** Exercise 3.11
#+begin_quote
Consider the bank account procedure of =Section 3.1.1=. Show the environment structure generated by the sequence of interactions
#+begin_src scheme
(define acc (make-account 50))
((acc 'deposit) 40)
90
((acc 'withdraw) 60)
30
#+end_src
Where is the local state for =acc= kept? Suppose we deﬁne another account
#+begin_src scheme
(define acc2 (make-account 100))
#+end_src
How are the local states for the two accounts kept distinct? Which parts of the environment structure are shared between =acc= and =acc2=?
#+end_quote

When =(define acc (make-account 50))= is called in the global environment we need to evaluate any sub-expressions. Beginning with the arguments =(make-account 50)=. Following the environment model we create a new frame in environment =E1= binding the formal paramter =balance= to \( 50 \). Then we bind all internal definitions of =withdraw=, =deposit= and =dispatch= in =E1=. Since =(make-account 50)= was called in the global environment =E1= will point to it. Since =(make-account 50)= returns =dispatch= that is what =acc= will be bound to in the global environment (which is where the =define= was called in first place).
[[../images/ch3/ex-3.11/make-acc.jpg]]

Now we proceed with =((acc 'deposit) 40)= by evaluating the sub-expression =(acc 'deposit)= in the global environment. =acc= points to the computational object =dispatch= and so we create a new environment =E2= where we bound the formal parameters of =dispatch= to ='deposit=. =E2= is enclosed by =E1= since that is the environment part of =dispatch=. The call to =(dispatch 'deposit)= returns the computational object =deposit=. Hence we need to evaluate =(deposit 40)=. We therefore create a new environment =E3= which will be enclosed by =E1=, again due to the fact that that is the environment part of =deposit=. In =E3= we bind the formal paramter of =deposit=, which is =amount= to \( 40 \). This call to =deposit= has the side-effect due to the use of =set!= in its body that mutates =balance= inside =E1=.
[[../images/ch3/ex-3.11/deposit.jpg]]

The =((acc 'withdraw) 60)= call is evaluated in a similar fashion creating two new ephermal environments =E4= and =E5=. The only difference is that =balance= is decremented.
[[../images/ch3/ex-3.11/withdraw.jpg]]

Finally, the call =(define acc2 (make-account 100))= sets up a new environment =E6= where =balance= is bound to \( 100 \). We see here that the two accounts are kept distinct by the fact that they have different environments. The only environment structure that shared between the two accounts is the global environment.
[[../images/ch3/ex-3.11/make-acc2.jpg]]
\newpage

** Modeling with Mutable Data
*** Exercise 3.12
#+begin_quote
Consider the interaction
#+begin_src scheme
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
(a b c d)
(cdr x)
⟨response⟩
(define w (append! x y))
w
(a b c d)
(cdr x)
⟨response⟩
#+end_src
What are the missing =⟨response⟩=? Draw box-and-pointer diagrams to explain your answer.
#+end_quote
We draw the box-and-pointer diagram for state up until defining the variable =z=. [[../images/ch3/ex-3.12/define-z.jpg]]
In doing so we see that the the first missing ~⟨response⟩~ is =(b)=. Let's now draw the diagram after =w= is defined. We are using the mutator procedure =append!= so the list structure is modified in-place. [[../images/ch3/ex-3.12/define-w.jpg]]
This time the missing response will be =(b c d)= since =x= was mutated when =w= was defined.
\newpage
*** Exercise 3.13
#+begin_quote
Consider the following make-cycle procedure, which uses the =last-pair= procedure deﬁned in Exercise 3.12:
#+begin_src scheme
  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
#+end_src
Draw a box-and-pointer diagram that shows the structure =z= created by
#+begin_src scheme
  (define z (make-cycle (list 'a 'b 'c)))
#+end_src
What happens if we try to compute ~(last-pair z)~?
#+end_quote
The procedure =make-cycle= will set the last pair's =cdr= of =(list 'a 'b 'c)= to the head of itself. This means that we have created a cycle over the ='(a b c)=. We draw the box-and-pointer diagram for =z= below.
[[../images/ch3/ex-3.13/cycle.jpg]]
As can be seen in the diagram above, if we try to evaluate ~(last-pair z)~ we will get an infinite loop since the last pair of =z= points to itself.
\newpage

*** Exercise 3.14
#+begin_quote
The following procedure is quite useful, although obscure:
#+begin_src scheme
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))
#+end_src
Draw the box-and-pointer diagram that represents the list to which v is bound. Suppose that we now evaluate =(define w (mystery v))=. Draw box-and-pointer diagrams that show the structures =v= and =w= after evaluating this expression. What would be printed as the values of =v= and =w=?
#+end_quote
We can observe that the value of =x= in =loop= will always be the tail of the previous =x= value. So that =temp= would be =(a b c d)=, =(b c d)=, ..., =(d)=, =()=. The =y= is always the previous iteration's mutated =x= value beginning with the empty list =()=. Since =x= is changed by taking its head and setting its =cdr= to be =y=, the values =y= take in each iteration are =()=, =(a)=, =(b a)=, ..., =(d c b a)=. This means that =(mystery x)= is effectively reversing the list =x=.

We draw the box-and-pointer diagram for =v= below.
[[../images/ch3/ex-3.14/define-v.jpg]]

After the call =(define w (mystery v))= we have reversed the list =v= and bound it to =w=. However, the first =set-cdr!= in =loop= will mutate the value pointed by =v= by setting the =cdr= to =y= which is initialized by the empty list. In the next iteration, =v= will be passed in =loop= as =y= which is not mutated and in fact dropped. This means we only mutate the value of =v= once to =(a)=. We draw the box-and-pointer diagram for =v= and =w= below.
[[../images/ch3/ex-3.14/define-w.jpg]]
\newpage

*** Exercise 3.15
#+begin_quote
Draw box-and-pointer diagrams to explain the effect of set-to-wow! on the structures =z1= and =z2= above.
#+end_quote
We draw the box-and-pointer diagram for =z1= and =z2= after the effects calling =set-to-wow!= on both of them, respectively.
[[../images/ch3/ex-3.15/set-to-wow.jpg]]
\newpage

*** Exercise 3.16
:PROPERTIES:
:header-args: :tangle "3.16.scm"
:END:
#+begin_quote
The number of pairs in any structure is the number in the car plus the number in the =cdr= plus one more to count the current pair.
#+begin_src scheme
  (define (count-pairs x)
    (if (not (pair? x))
        0
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))
#+end_src
Show that this procedure is not correct. In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben’s procedure would return 3; return 4; return 7; never return at all.
#+end_quote
We begin with the first two cases, where we construct =w= to return 3 and =x= to return 4.
#+begin_src scheme
  (define b (cons 'b '()))
  (define a (cons 'a b))

  (define w (cons a '()))
  (count-pairs w)                         ; returns 3

  (define x (cons a b))
  (count-pairs x)                         ; returns 4
#+end_src
The diagrams for these two cases are shown below.
[[../images/ch3/ex-3.16/pair-3-4.jpg]]
For the third we construct =y= to return 7.
#+begin_src scheme
  (define bb (cons b b))
  (define y (cons bb bb))
  (count-pairs y)                         ; returns 7
#+end_src
For the last case we simply let =z= to be a cycle using the =make-cycle= procedure from =Exercise 3.13=. We show diagrams below
 #+begin_src scheme
   (define (make-cycle x)
     (set-cdr! (last-pair x) x)
     x)

   (define z (make-cycle (cons 'a (cons 'b (cons 'c '())))))
   ;; (count-pairs z)                         ; will never halt
 #+end_src
[[../images/ch3/ex-3.16/pair-7-inf.jpg]]
\newpage

*** Exercise 3.17
#+begin_quote
Devise a correct version of the count-pairs procedure of =Exercise 3.16= that returns the number of distinct pairs in any structure. (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)
#+end_quote
We will implement a set data structure, admittedly ineffienct. We will use the =memq= procedure to check if an element is in the set and =cons= to add the element to the set. The number of pairs will be the length of our set.
#+begin_src scheme
  (define (count-pairs x)
    (define seen-pair '())
    (define (count x)
      (cond ((not (pair? x)) 0)
            ((memq x seen-pair) 0)
            (else (set! seen-pair (cons x seen-pair))
                  (+ (count (car x))
                     (count (cdr x))
                     1))))
    (count x))
#+end_src
Using this new version of =count-pairs= with the list structres we defined in =Exercise 3.16=, all results are returned correctly as 3.
\newpage

*** Exercise 3.18
:PROPERTIES:
:header-args: :tangle "3.18.scm"
:END:
#+begin_quote
Write a procedure that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive =cdrs= would go into an infinite loop. =Exercise 3.13= constructed such lists.
#+end_quote
We can construct a path of =cons= by following each successive =cdr= of a list. If such a path of =cons= has a cycle, then at least one of the =cons= in the path points back to a previous =cons= in the path. We write the procedure =has-cycle?= using this fact.
#+begin_src scheme
  (define (has-cycle? x)
    (define (cycle-in-path? x path)
      (cond ((not (pair? x)) #f)
            ((memq (cdr x) path) #t)
            (else (cycle-in-path? (cdr x) (cons x path)))))
    (cycle-in-path? x (list x)))
#+end_src
Let's test this procedure by creating a cycle and a non-cycle. From =Exercise 3.13= we use the procedure =make-cycle=.
#+begin_src scheme
  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
#+end_src
Next let us define =x= with no cycle and =z= with a cycle.
#+begin_src scheme
  (define x '(a b c))
  (define z (cons 'a (make-cycle (cons 'a 'b))))
#+end_src
We can now test our procedure by calling =has-cycle?= on =x= and =z=.
#+begin_src scheme
  (has-cycle? x)                           ; returns #f
  (has-cycle? z)                           ; returns #t
#+end_src
However, note that we construct the path by =cdr=-ing down the list. This means that if we have a cycle in the =car= part of the list, then we will not detect it. We could easily amend this by adjusting the =cycle-in-path?= to check for cycles in the =car= part of the list as well.
#+begin_src scheme
  (define (cycle-in-path? x path)
    (cond ((not (pair? x)) #f)
          ((or (memq (car x) path) (memq (cdr x) path)) #t)
          (else (or (cycle-in-path? (car x) (cons x path))
                    (cycle-in-path? (cdr x) (cons x path))))))
#+end_src
\newpage

*** Exercise 3.19
#+begin_quote
Redo =Exercise 3.18= using an algorithm that takes only a constant amount of space. (This requires a very clever idea.)
#+end_quote
We can use the famous =tortoise-and-hare= algorithm for detecting cycles in a list. The idea is to have two pointers, one that moves one step at a time and another that moves two steps at a time. If there is a cycle in the list, then the two pointers will eventually point to the same =cons= in the list. We omit the proof here.

Since we only use two pointers to travers in addition to the list, this algorithm takes constant space. We write the procedure =has-cycle?= using this idea.
#+begin_src scheme
  (define (has-cycle? x)
    (define (tortoise-and-hare tortoise hare)
      (cond ((not (pair? hare)) #f)
            ((eq? tortoise hare) #t)
            (else (tortoise-and-hare (cdr tortoise) (cddr hare)))))
    (tortoise-and-hare x (cdr x)))
#+end_src
Note that the procedure above only works for non-empty lists. We can easily amend this by adding a conditional before the call to =tortoise-and-hare= in =has-cycle?=. But we omit it to not clutter the code.
\newpage

*** Exercise 3.20
#+begin_quote
Draw environment diagrams to illustrate the evaluation of the sequence of expressions
#+begin_src scheme
  (define x (cons 1 2))
  (define z (cons x x))
  (set-car! (cdr z) 17)
  (car x)
  17
#+end_src
using the procedural implementation of pairs given above. (Compare =Exercise 3.11=.)
#+end_quote
=cons= points to a procedure enclosed by the global environment with parameters =x, y=. When defining =x= we create a new frame =E1= where we bound =cons= parameters to =1, 2= and evaluate the body. We see the result in the diagram below.
[[../images/ch3/ex-3.20/define-x.jpg]]

Similarly, when defining =z= we create a new frame =E2=, but this time bound =cons= parameters to =x, x=.
[[../images/ch3/ex-3.20/define-z.jpg]]

Now we want to evaluate the compound expression =(set-car! (cdr z) 17)=. First we need to evaluate all sub-expressions. This means we begin with =(cdr z)= since =17= is a primitve. Therefore we create a new frame =E3= where we bound =cdr= parameters to =z= and evaluate the body.

This leaves us the expression =(z 'cdr)= and we look in the global enviroment after =z=. We find that =z= points to a procedural object called =dispatch= in =E2=. As before, create a new frame =E4= and bind the =dispatch='s parameter =m= to ='cdr=. Evaluation of the body gives us the symbol =x=.

The expression we need to evaluate now is =(set-car! x 17)=. At this point every sub-expression is known in the global environment so we must apply =set-car!= to the parameters. Hence, we create a new frame =E5= and bind =set-car!='s parameters to =x, 17= and leaves us with the expression =(((x 'set-car!) 17) x)=.

The sub-expression =(x 'set-car!)= is evaluated in a new frame =E6= and results in =set-x!= procedure defined in enviroment =E1=. We have =((set-x! 17) x)= left to evaluate. For =(set-x! 17)= we create a new frame =E7= enclosed by =E1=. Following the procedure =set-x!= and binding its parameter to =17= has the effect of setting the =car= of =x= to the value =17=. Lastly, we just return =x= back to the caller.
[[../images/ch3/ex-3.20/set-car.jpg]]

The final result is that the =car= value of =x= was mutated. Since =cdr z= points to =x=, =z= will also be affected by this as a side-effect.
[[../images/ch3/ex-3.20/final.jpg]]

=Exercise 3.11= is similar in that we have internal definitions and variables. So the two evaluations of =cons= leads to two enviroments =E1= and =E2=, both of which have their own =dispatch=, exactly as in =Exercise 3.11=. However, a difference here is that when defining =z= we bind it to the previously created =x= -- in effect coupling them as we've seen in the final result.
\newpage

*** Exercise 3.21
#+begin_quote
Ben Bitdiddle decides to test the queue implementation described above. “It’s all wrong!” he complains. “The interpreter’s response shows that the last item is inserted into the queue twice. Show why Ben’s examples produce the printed results that they do. Define a procedure =print-queue= that takes a queue as input and prints the sequence of items in the queue.
#+end_quote
A sequence of =cons= terminated by ='()= is printed as a list in Scheme. Hence
#+begin_src scheme
  (cons 'a '())
  (a)
  (cons 'a 'b)
  (a . b)
#+end_src
When we evaluate the following expressions, as Ben Bitdiddle does,
#+begin_src scheme
  (define q1 (make-queue))
  (insert-queue! q1 'a)
#+end_src
then =q1= will point to the pair =(cons (cons 'a '()) (cons 'a '()))=. Therefore the print will be
#+begin_src scheme
  ((a) a)
#+end_src
There's a nested parenthesis to distinguish that the =car= is a list in its own, which we wouldn't have seen if it was printed without them like so =(a a)=. Subsequent insertion =(insert-queue! q1 'b)= will make =q1= to point to the pair =(cons (cons 'a (cons 'b '())) (cons 'b '()))= and print =((a b) b)=. However, do note that =rear-ptr= is just a pointer to the =last-pair= in =(cons 'a (cons 'b '()))= as can be seen in the diagram below.
#+ATTR_LATEX: :width 0.40\textwidth
[[../images/ch3/ex-3.21/insert-queue.jpg]]
To define a procedure =print-queue= we simply traverse the queue starting from the =front-ptr= and =cdr= until we reach the end of the queue. We print the =car= of each pair along the way. But this is what Scheme already does when we print a list. So we can just return the =front-ptr= and Scheme will print it for us.
#+begin_src scheme
  (define (print-queue q)
    (front-ptr q))
#+end_src
\newpage

*** Exercise 3.22
#+begin_quote
Complete the definition of =make-queue= and provide implementations of the queue operations using this representation.
#+begin_src scheme
  (define (make-queue)
    (let ((front-ptr . . . )
          (rear-ptr . . . ))
      ⟨definitions of internal procedures⟩
      (define (dispatch m) . . .)
      dispatch))
#+end_src
#+end_quote
We initialize =front-ptr= and =rear-ptr= to be empty lists. Whenever we insert an =item=, we simply tack the pair =(cons item '())= onto the current rear, and then =set!= the =rear-ptr= to this pair. For deletion we simply set =front-ptr= to its =cdr=.
#+begin_src scheme
  (define (make-queue)
    (let ((front-ptr '())
          (rear-ptr '()))
      (define (empty?) (null? front-ptr))
      (define (insert! item)
        (let ((new-pair (cons item '())))
          (cond ((empty?)
                 (set! front-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr)
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr))))
      (define (delete!) (set! front-ptr (cdr front-ptr)) front-ptr)
      (define (dispatch m)
        (cond ((eq? m 'empty?) (empty?))
              ((eq? m 'front) (car front-ptr))
              ((eq? m 'insert!) insert!)
              ((eq? m 'delete) (delete!))
              ((eq? m 'print) front-ptr)))
      dispatch))
#+end_src
Now we define the rest of interface for =queue= in terms of the =dispatch=.
#+begin_src scheme
  (define (delete-queue! queue) (queue 'delete))
  (define (empty-queue? queue) (queue 'empty?))
  (define (front-queue queue) (queue 'front))
  (define (insert-queue! queue item) ((queue 'insert!) item))
  (define (print-queue queue) (queue 'print))
#+end_src
\newpage

*** Exercise 3.23
#+begin_quote
A /deque/ (“double-ended queue”) is a sequence in which items can be inserted and deleted at either the front or the rear. Operations on deques are the constructor =make-deque=, the predicate =empty-deque?=, selectors =front-deque= and =rear-deque=, mutators =front-insert-deque!=, =rear-insert-deque!=, =front-delete-deque!=, and =rear-delete-deque!=. Show how to represent deques using pairs, and give implementations of the operations. All operations should be accomplished in \( \Theta (1) \) steps.
#+end_quote
We begin by making an abstraction of the elements that go into our deque. This is not necessary but helps with readiblity of the code. Each element is called a =node= and consists of an item and two pointers =prev= and =next=. If a =node= is the first element in the deque, then its =prev= pointer will be empty. Similarly, if a =node= is the last element in the deque, then its =next= pointer will be empty. We can define the =deque= simply by a =cons= with elements of type =node=. The image below shows a =deque= of three nodes which hold items =a, b, c=, respectively. We mark the middle =node= in the image with a dashed box.
                   [[../images/ch3/ex-3.23/deque.jpg]]
As can be seen in the diagram above, we define a =node= to consts of two pairs. In addtion, we provide helpers =prev=, =next= and their mutators to facilitate creating the =deque= later on.
#+begin_src scheme
  (define (make-node item)
    (cons (cons item '()) '()))
  (define (item node) (caar node))
  (define (prev node) (cdar node))
  (define (next node) (cdr node))
  (define (set-prev! node item) (set-cdr! (car node) item))
  (define (set-next! node item) (set-cdr! node item))
#+end_src
We can now define the =deque= and implements its interface with help of the facilities of =node=.
#+begin_src scheme
  (define (make-deque) (cons '() '()))
  (define (front-deque deque) (car deque))
  (define (rear-deque deque) (cdr deque))
  (define (empty-deque? deque) (null? (front-deque deque)))
  (define (set-front! deque item) (set-car! deque item))
  (define (set-rear! deque item) (set-cdr! deque item))
  (define (front-insert-deque! deque item)
    (cond ((empty-deque? deque)
           (let ((new-pair (make-node item)))
             (set-front! deque new-pair)
             (set-rear! deque new-pair)
             #t))
          (else
           (let ((new-item (make-node item)))
             (set-prev! (front-deque deque) new-item)
             (set-next! new-item (front-deque deque))
             (set-front! deque new-item)
             #t))))

  (define (rear-insert-deque! deque item)
    (cond ((empty-deque? deque)
           (let ((new-pair (make-node item)))
             (set-front! deque new-pair)
             (set-rear! deque new-pair)
             deque))
          (else
           (let ((new-rear (make-node item))
                 (current-rear (rear-deque deque)))
             (set-next! current-rear new-rear)
             (set-prev! new-rear current-rear)
             (set-rear! deque new-rear)
             #t))))

  (define (front-delete-deque! deque)
    (cond ((empty-deque? deque) #t)
          ((null? (next (front-deque deque)))
           (set-front! deque '())
           (set-front! deque '())
           #t)
          (else
           (let ((new-front (next (front-deque deque))))
             (set-prev! new-front '())
             (set-front! deque new-front)
             #t))))

  (define (rear-delete-deque! deque)
    (cond ((empty-deque? deque) #t)
          ((null? (prev (rear-deque deque)))
           (set-rear! deque '())
           (set-front! deque '())
           #t)
          (else
           (let ((new-rear (prev (rear-deque deque))))
             (set-next! new-rear '())
             (set-rear! deque new-rear)
             #t))))
#+end_src
In order to avoid Scheme printing the cycle we have in the =deque=, some of our operations simply output =#t=. However, we also provide the =print-deque= procedure which prints the =item= of each =node= in the =deque=.
#+begin_src scheme
  (define (print-deque deque)
    (define (iter node)
      (if (null? node)
          '()
          (cons (item node) (iter (next node)))))
    (iter (front-deque deque)))
#+end_src
Let's test our implementation by creating a =deque= and inserting and deleting elements.
#+begin_src scheme
  (define d (make-deque))
  (empty-deque? d)                        ; returns #t
  (front-insert-deque! d 2)
  (empty-deque? d)                        ; returns #f
  (front-insert-deque! d 1)
  (rear-insert-deque! d 3)
  (print-deque d)                         ; returns (1 2 3)

  (rear-delete-deque! d)
  (print-deque d)                         ; returns (1 2)
  (front-delete-deque! d)
  (print-deque d)                         ; returns (2)
  (rear-delete-deque! d)
  (empty-deque? d)                        ; returns #t
#+end_src
\newpage

*** Exercise 3.24
#+begin_quote
Design a table constructor =make-table= that takes as an argument a =same-key?= procedure that will be used to test “equality” of keys. =make- table= should return a =dispatch= procedure that can be used to access appropriate =lookup= and =insert!= procedures for a local table.
#+end_quote
The only difference would be that our =assoc= in this case uses =same-key?= to test for equality.
#+begin_src scheme
  (define (assoc key records)
    (cond ((null? records) false)
          ((same-key? key (caar records)) (car records))
          (else (assoc key (cdr records)))))
#+end_src
This new =assoc= can be used as a local definition inside the =make-table= procedure.
#+begin_src scheme
  (define (make-table same-key?)
    (let ((local-table (list '*table*)))
      (define (assoc key records)
        (cond ((null? records) false)
              ((same-key? key (caar records)) (car records))
              (else (assoc key (cdr records)))))
      (define (lookup key)
        (let ((record (assoc key (cdr local-table))))
          (if record
              (cdr record)
              false)))
      (define (insert! key value)
        (let ((record (assoc key (cdr local-table))))
          (if record
              (set-cdr! record value)
              (set-cdr! local-table
                        (cons (cons key value)
                              (cdr local-table)))))
        'ok)
      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              (else (error "Unknown operation: TABLE" m))))
      dispatch))
#+end_src
To test we simply need to provide a =same-key?= procedure and create a table with it
#+begin_src scheme
  (define (same-key? key-1 key-2) (< (abs (- key-1 key-2)) 0.5))
  (define operation-table (make-table same-key?))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
#+end_src
and now we are ready to use the table.
#+begin_src scheme
  (put 1.0 'a)
  (put 2.0 'b)
  (get 1.4)                               ; returns 'a
  (get 2.5)                               ; returns #f
  (get 1.9)                               ; returns 'b
#+end_src
\newpage

*** Exercise 3.25
#+begin_quote
Generalizing one- and two-dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under diﬀerent numbers of keys. The =lookup= and =insert!= procedures should take as input a list of keys used to access the table.
#+end_quote
To generalize the table we need to have the ability to create sub-tables for any key where appropriate. We can do this by using the same =make-table= procedure as in =Exercise 3.24= but modify =insert!= to create sub-tables on the fly when needed. To do so we have to take care of a few base cases.
+ If we only have one key =(null? (cdr keys))= we either have to insert the value in the record if it exists or put it inside a new record that we store the table.

+ If we have more than one key we need to check if the record exists =(eq? record false)=.
  + If it does not exist we need to create a new sub-table and recursively insert the value in it.
  + If it does exist we need to check if it is a sub-table =(pair? (cdr record))=.
    + If it is a sub-table we need simply recursively insert the value in the sub-table.
    + If it is not a sub-table we remove the value-part of the record =(set-cdr! record '())= and insert our value in the record as if the record would be a sub-table =(insert! (cdr keys) value record))=.
#+begin_src scheme
  (define (insert! keys value table)
    (let ((record (assoc (car keys) (cdr table))))
      (cond ((null? (cdr keys))
             (if record
                 (set-cdr! record value)
                 (set-cdr! table (cons (cons (car keys) value) (cdr table)))))
            (else
             (cond ((eq? record false)
                    (let ((new-table (cons (cons (car keys) '()) (cdr table))))
                      (set-cdr! table new-table)
                      (insert! (cdr keys) value (car new-table))))
                   ((not (pair? (cdr record)))
                    (set-cdr! record '())
                    (insert! (cdr keys) value record))
                   (else (insert! (cdr keys) value record)))))))
#+end_src
We also need to modify =lookup= to be able to traverse the sub-tables given a set of keys. This is fairly straight forward and we can use the same =assoc= as in =Exercise 3.24=.
#+begin_src scheme
  (define (lookup keys table)
    (let ((record (assoc (car keys) (cdr table))))
      (cond ((null? (cdr keys))
             (if record
                 (cdr record)
                 false))
            ((and record (pair? (cdr record)))
             (lookup (cdr keys) record))
            (else false))))
#+end_src
Now we can put it all together under =make-table= which our interface will use.
  #+begin_src scheme
    (define (make-table)
      (let ((local-table (list '*table*)))
        (define (lookup keys table)
          (let ((record (assoc (car keys) (cdr table))))
            (cond ((null? (cdr keys))
                   (if record
                       (cdr record)
                       false))
                  ((and record (pair? (cdr record)))
                   (lookup (cdr keys) record))
                  (else false))))
        (define (insert! keys value table)
          (let ((record (assoc (car keys) (cdr table))))
            (cond ((null? (cdr keys))
                   (if record
                       (set-cdr! record value)
                       (set-cdr! table (cons (cons (car keys) value) (cdr table)))))
                  (else
                   (cond ((eq? record false)
                          (let ((new-table (cons (cons (car keys) '()) (cdr table))))
                            (set-cdr! table new-table)
                            (insert! (cdr keys) value (car new-table))))
                         ((not (pair? (cdr record)))
                          (set-cdr! record '())
                          (insert! (cdr keys) value record))
                         (else (insert! (cdr keys) value record)))))))
        (define (dispatch m)
          (cond ((eq? m 'lookup-proc) (lambda (keys) (lookup keys local-table)))
                ((eq? m 'insert-proc!) (lambda (keys value) (insert! keys value local-table)))
                (else (error "Unknown operation: TABLE" m))))
        dispatch))
#+end_src
Let's make a table to test our implementation with
#+begin_src scheme
  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
  (define print (operation-table 'print))
#+end_src
which we use in the test below
#+begin_src scheme
  (put '(1) 'a)
  (put '(2) 'b)
  (get '(1))                              ; returns 'a
  (get '(2))                              ; returns 'b
  (put '(1 1) 'c)
  (put '(1 2) 'd)
  (get '(1))                              ; returns table ((1 . c) (2 . d))
  (get '(1 1))                            ; returns 'c
  (get '(1 2))                            ; returnc 'd
  (get '(2))                              ; returns 'b
#+end_src
\newpage

*** Exercise 3.26
#+begin_quote
Describe a table implementation where the (key, value) records are organized using a binary tree, as-
suming that keys can be ordered in some way (e.g., numerically or alphabetically).
#+end_quote
We describe an implementation of a one-dimensional table using binary trees. From =Chapter 2= in =Section 2.3.3= we have the interface for a binary tree
#+begin_src scheme
  (define (entry tree) (car tree))
  (define (left-branch tree) (cadr tree))
  (define (right-branch tree) (caddr tree))
  (define (make-tree entry left right)
    (list entry left right))
  (define (adjoin-set x set)
    (cond ((null? set) (make-tree x '() '()))
          ((= (car x) (car (entry set))) set)
          ((< (car x) (car (entry set)))
           (make-tree (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch set)))
          ((> (car x) (car (entry set)))
           (make-tree (entry set) (left-branch set)
                      (adjoin-set x (right-branch set))))))
#+end_src
where we made a slight modification to =adjoin-set= so that it works with key-value pairs. We also want a procedure that fetch us an entry if it exists. Such a procedure is easily gotten by modifying =element-of-set?= to return the actual entry it finds as opposed to a boolean. We call this procedure =find-entry= and adopt it so it works for key value pairs.
#+begin_src scheme
  (define (find-entry key set)
    (cond ((null? set) false)
          ((= key (car (entry set))) (entry set))
          ((< key (car (entry set))) (find-entry key (left-branch set)))
          (else (find-entry key (right-branch set)))))
#+end_src
Now we use the binary tree to implement our table. We let an empty table be represented as the empty list ='()=.
#+begin_src scheme
  (define (make-table)
    (let ((local-table '()))
      (define (lookup key)
        (let ((record (find-entry key local-table)))
          (if record
              (cdr record)
              false)))
      (define (insert! key value)
        (let ((record (find-entry key local-table)))
          (if record
              (set-cdr! record value)
              (set! local-table (adjoin-set (cons key value) local-table))))
        'ok)
      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              (else (error "Unkown operation: TABLE" m))))
      dispatch))
#+end_src
Note that =lookup= is nearly identical to =element-of-set?= procedure from =Chapter 2=. To conclude this exercise we create a test
#+begin_src scheme
  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (put 1 'a)
  (put 2 'b)
  (get 1)                             ; returns 'a
  (get 2)                             ; returns 'b
  (put 1 'c)
  (get 1)                             ; returns 'c
  (get 2)                             ; returns 'b
#+end_src
It is easy to see how we can extend this implementation to work non-numerical keys. We simply need to provide =same-key?=, =less-than?= and =greater-than?= procedures to =adjoin-set= and =find-entry=.
\newpage

*** Exercise 3.27
#+begin_quote
Draw an environment diagram to analyze the computation of =(memo-fib 3)=. Explain why =memo-fib= computes the \( n^\mathrm{th} \) Fibonacci number in a number of steps proportional to \( n \). Would the scheme still work if we had simply deﬁned memo- fib to be =(memoize fib)=?
#+end_quote
Beginning with the evaluation of =(define (memoize f) ...)= we get a procedural object which is enclosed by the global environment. This object has =f= as its formal parameter.

Next we evaluate the expression =(define memo-fib (memoize (lambda (n) ...)))=. First evaluate the sub-expression that is =(lambda (n) ...)=. This results in a procedural object with formal parameter =n= and since we evaluated this in the global environment that would enclose this object. Now we look up =memoize= in the global environment and bind its formal parameter =f= to the procedural object we just created in a new frame =E1=. This leads us to a =let= expression we can now evaluate in a new frame =E2= which would be enclosed by =E1=. In =E2= we bind =table= to the result of =make-table=. This results in a new procedural object which is enclosed by =E2= and has =x= as its formal parameter. This object is returned and bound to =memo-fib= in the global environment.
[[../images/ch3/ex-3.27/memo-fib.jpg]]

When we call =(memo-fib 3)= we create a new environment where we have bound =x= to 3. We run the lookup procedure and find that there is no entry for this argument. Hence we must use =f= to calculate the result which we can insert into the =table=. We find =f= in =E1= from =E2=. We create a new frame where =n= is bound to 3 and evaluate the body of =f=. This results in us having to call =(memo-fib 2)= and =(memo-fib 1)=. We find these in the global environment enclosed by =E2=, which means both of these call will have access to the same =table= variable. These in turn will have to be evaluated and can lookup/insert data into the =table= that can be accessed by later calls to =memo-fib=. At the end of the computation we have a =table= that contains the results of all calls to =memo-fib=. Here we have assumed that the right-most argument gets evaluated first. This will impact the order in which the =table= is filled.
[[../images/ch3/ex-3.27/memo-fib-3.jpg]]

We now show that the number of steps to calculate the \( n^\mathrm{th} \) Fibonacci number is proportional to \(n\). We see that in each call to =memo-fib= we spawn two new calls to =memo-fib= with \(n-1\) and \(n-2\) as arguments. So the number of steps to get to =0= is proportional to \(n\). However, note that the call =(memo-fib n-1)= would also call =(memo-fib n-2)= which means we would calculate =(memo-fib n-2)= at least twice. But since we store previous results in the =table= we can simply look up the result of =(memo-fib n-2)= in the =table= instead of recalculating it and thus avoid the extra computation. This is why =memo-fib= computes the \( n^\mathrm{th} \) Fibonacci number in a number of steps proportional to \( n \).

Lastly, the scheme would work sub-optimally if we had =(define memo-fib (memoize fib))=. This is because only the result of the first call =(memo-fib 3)= would be inserted in the =table=. All of the other recursive calls to  calculate the previous Fibonacci number use =fib=, which is defined in the global environment. =fib= is a procedure that does not store anything in a =table= (even if it would it has no access to =table= defined in =E2=).
[[../images/ch3/ex-3.27/memo-with-fib.jpg]]
