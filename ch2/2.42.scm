;; given queen, flatmap, enumerate-interval
(define (flatmap proc seq)
  (fold-right append '() (map proc seq)))
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
	(list empty-board)
	(filter
	 (lambda (positions) (safe? k positions))
	 (flatmap
	  (lambda (rest-of-queens)
	    (map (lambda (new-row)
		   (adjoin-position
		    new-row k rest-of-queens))
		 (enumerate-interval 1 board-size)))
	  (queen-cols (- k 1))))))
  (queen-cols board-size))
;; position :: a pair of row and column, (2 1)
(define (make-position row col) (list row col))
(define (get-row position) (car position))
(define (get-col position) (cadr position))
;; board :: list of positions
(define empty-board '())
(define (adjoin-position row column positions)
  (cons (make-position row column) positions))
(define (diff-row? queen other-queen)
  (not (= (get-row queen) (get-row other-queen))))
(define (diff-diag? queen other-queen)
  (not (= (abs (- (get-row queen) (get-row other-queen)))
	  (abs (- (get-col queen) (get-col other-queen))))))
(define (queen-at k positions)
  (car (filter (lambda (pos) (= k (get-col pos))) positions)))
(define (queens-not-at k positions)
  (filter (lambda (pos) (not (= k (get-col pos)))) positions))
(define (safe-positions queen other-queens)
  (filter (lambda (other) (diff-row? queen other))
	  (filter (lambda (other) (diff-diag? queen other)) other-queens)))
(define (safe? k positions)
  (= (- k 1)
     (length (safe-positions
	      (queen-at k positions)
	      (queens-not-at k positions)))))
